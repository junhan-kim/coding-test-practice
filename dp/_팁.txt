1. top down

int dp[n];
for(int i = 0; i < n; i++){ dp[i] = -1; }   // 메모 초기화

int fibonacci(int n) // [불변 인자] + 현재 상태값
{
    if (n == 0) return 0;   // 베이스(리프) 도달 여부 체크 or 에러 처리
    if (n == 1) return 1;   // 
 
    if (dp[n] != -1) return dp[n];  // 메모 있으면 get
 
    dp[n] = fibonacci(n - 1) + fibonacci(n - 2);  // 메모 put 및 점화식
    return dp[n];  // 리턴값은 '문제에서 요구하는 값'(베이스 케이스 포함)
}

res = fibonacci(N); // 목표(루트) 위치 N에서 시작

<풀이법>
1. 재귀 형태로 만들 수 있는 문제인지 판단
2. 베이스 케이스, 계산 결과 리턴 -> 재귀 형태 만들기      // 재귀만으로도 풀리긴함. 단 탐색시간이 기하급수적으로 늘어나서 시간초과
3. 메모 초기화, 메모 get, 메모 put -> 메모이제이션 추가  // 메모리를 조금 더 써서 시간을 획기적으로 줄임 

<유형>
최대값 or 최소값 구하기 (최적해) 

<팁>★★★
1. depth가 500이상 정도로 '깊은 경우' -> 재귀로는 불가능  
   '반복문' 형태의 상향식 패턴으로 짜기.  앞에서부터 접근하고 다시 '뒤로 되돌아가지 않음'. '앞에서 계산한 내용을 뒤에서 활용'
   현재 결과가 이전 결과에 대해 종속적이라면, '이전결과->현재결과인 방향으로 진행'해야함. 문제에서 제시된 관점의 방향과 다를 수 있음.   ex) 카드게임
   or
   '목표값을 루트 노드'로하여 하향식 패턴으로 짜기. (목표값이 여러 점으로 발산하더라도 무조건 목표값에서 시작(즉, back to front))  ex) 정수삼각형
   즉, 목표가 M,N 이라면 cal(1,1)이 아닌, 'cal(M,N)'에서 시작해야함.  answer = cal(M,N) 
     -> 목표가 '여러 점인 경우, 각각에서 모두 dp 한뒤 sort' 해서 푸는 기법을 사용함. 단 이 방식은 한계가 있고, 코드와 로직이 매우 복잡해질 우려가 있음.
2. 리턴값은 반드시 '문제에서 요구하는 값' 이어야 한다. (요구하는 값을 인자에 넣거나 하면 안됨)  그래야 메모이제이션에 문제가 없음
   인자 전달 -> 함수가 시작될때 '입력' 되는 값 -> push 할때 내려보내지는 값 -> dp에선 상태 관리용
   리턴값 전달 -> 함수가 끝날때 '반환' 되는 값 -> pop 할때 위로 올라오는 값 -> dp에선 결과값(문제에서 요구하는 목표값) 산출용
   ex) 카드게임

<인간적인 관점에서의 해설>
1. 하향식
 결국 탐색기법을 활용하는 이유는, t=0인 현재 시점에서 t=n인 이후 시점까지의 모든 가능성을 탐색하고, 그 가능성 중 최선인 결과를 알고 싶은 것임.
 그 구조는 트리와도 같고, 평행우주론과도 같다. 하나의 루트에서 2개이상의 가지가 뻗어나가고, 각 가지에서 또 가지가 뻗어나가는데, 단 그 깊이는 유한하다.
 유한하다면 그 나무의 가장 끝에 해당하는 리프노드들이 있을 것이고, 거기에서부터 분할된 분기들이 하나로 합쳐지면서 각 분기에서의 최적값을 도출하고 그 과정이 루트까지 이어진다.
 조금 더 디테일하게 설명한다면, 이 트리를 구성하는 각 노드들은 입력(패러미터)과 출력(리턴)이 존재한다.
 입력에서는 여러 상태값을 받을 수 있다. 이 상태값들은 현재 노드가 전체 노드들 중 어떤 노드인지를 식별할 수 있는 ID와 같은 역할을 한다.
 물론 일반적인 코테에서는 너무 복잡한 구조를 사용할 수 없고, 그 ID와 연관된 자료에 접근할 구조를 짤 시간도 없을 것이므로 결국 대부분은 배열을 사용한다.
 배열의 인덱스에 -1이나 +1을 하여 인접해있는 자식노드로 접근할 수 있게 된다. 이 과정에서는 연산을 한다기보단 그냥 무수히 많은 분기가 생성된다.
 모든 분기가 만들어졌으면 제일 하위 노드(리프 노드)부터 병합의 과정을 거치게 된다. 리프 노드는 자신만의 고유 값을 상위 노드에 전달한다.
 리프 노드의 상위 노드에서는 자신의 아래에 위치한 여러 리프노드들의 고유값을 비교하여 최적값을 산출한다.(보통 문제에서는 최대 or 최소값이다)
 이 과정이 아래에서부터 순차적으로 진행되어 결과적으로 루트노드까지 반복되고, 루트노드에선 모든 가능성 중 가장 최적인 값을 얻게 되는 것이다.
 ★요약 : 루트부터 자식으로 상태를 전파하며 트리의 구조를 만들고, 모든 구조가 완성되면 각 노드에선 하위노드들 중 최적값을 선별하여 부모노드로 전달하고, 결국 리프까지 보내는 것이다. 

 그러나 이 과정에서 각 분기는 독립적이지 않은 경우가 많다. 
 왜냐하면 대회에선 각 노드를 구분하게 해주는 상태값으로 배열의 인덱스를 사용하는데, 이는 겹치는 경우가 많기 때문이다.
 상태를 표현하는 값이 다양할수록 메모를 활용하기는 힘들어진다. 평행우주에서 상태는 3차원 공간이 되므로 무수히 많은 정보가 필요하고, 이 경우 메모의 활용가치는 매우 떨어진다.
 여러 분기가 서로 부모자식으로 얽혀있는 경우(삼각형, 길찾기 등)에는 '특정 상태와 그 상태에서의 산출값'을 매핑해주는 메모를 활용할 수 있다.
 그래서 리턴값이 반드시 문제에서 요구하는 목표값이어야 하는 이유가 여기에 있다. 애초에 메모는 상태(인덱스)와 그 상태에서의 산출값(목표값)을 매핑하는 역할이기 때문이다.
 상태는 보통 시간에 따른 결과물인 경우가 많다. 물론 로직을 짤때는 추상화의 과정을 거치므로 우리가 시간이니 어쩌니 하는 것을 고려할 필요는 없다.

2. 상향식
 이 방식은 하향식과 달리 리프노드부터 시작하는 방식이다. 리프노드부터 순차적으로 중간결과를 저장하고, 부모노드에선 자식노드의 값을 사용하여 연산한다.
 일단 재귀의 과정이 없기떄문에 속도가 빨라서 depth가 일정수준이상 깊은 경우에는 상향식을 사용한다.
 위에선 마치 재귀처럼 설명했지만 사실 이 방식은 분기로 이해하기보다는 건축으로 이해하는 것이 더 쉽다.
 가장 밑바닥부터 현재 상태의 결과를 연산해놓고 이후 상태에서는 계속하여 이전 상태에서 저장한 값을 사용하여 쌓아나가는 방식이다. (그러므로 이 자체가 사실상 메모이다)
 그래서 앞이던 뒤던 방향이 별로 중요하지 않은 재귀와 달리, 상향식은 방향이 매우 중요하다.  어떤것이 이전이고 이후인지에 대한 종속성을 알아야 하기 떄문이다.
 이 종속성에 의해 이전이라고 판단되는 것을 먼저 처리하여 이후에서 사용할 수 있게 해야한다.
 중요한 것은 여기서 이전과 이후라는 개념은 실제 시간 개념과는 다르다. 즉 문제에서 주어진 시간의 선후관계와 다를 수 있다는 말이다.
 시간과는 별개로 각 상태끼리의 종속성을 판단하고, 종속성이 없는 곳에서 종속성이 있는 곳으로 진행해야 한다.
 결과적으로 가장 종속성이 많이 필요한 상태에 해당하는 곳이 목표값이 산출되는 상태(재귀에서의 루트)에 해당된다.
 

 
 
 
 