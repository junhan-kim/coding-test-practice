1. top down

int dp[n];
for(int i = 0; i < n; i++){ dp[i] = -1; }   // 메모 초기화

int fibonacci(int n) // [불변 인자] + 현재 상태값
{
    if (n == 0) return 0;   // 베이스(리프) 도달 여부 체크 or 에러 처리
    if (n == 1) return 1;   // 
 
    if (dp[n] != -1) return dp[n];  // 메모 있으면 get
 
    dp[n] = fibonacci(n - 1) + fibonacci(n - 2);  // 메모 put 및 점화식
    return dp[n];  // 리턴값은 문제에서 요구하는 값(베이스 케이스 포함)
}

res = fibonacci(N); // 목표(루트) 위치 N에서 시작

<풀이법>
1. 탐색의 구조를 재귀 형태로 만들 수 있는 문제인지 판단
2. 베이스 케이스, 계산 결과 리턴 -> 재귀 형태 만들기      // 재귀만으로도 풀리긴함. 단 탐색시간이 기하급수적으로 늘어나서 시간초과
3. 메모 초기화, 메모 get, 메모 put -> 메모이제이션 추가  // 메모리를 조금 더 써서 시간을 획기적으로 줄임 

<유형>
최대값 or 최소값 구하기 (최적해) 

<팁>
1. 무조건 목표값을 루트 노드로하여 하향 재귀 패턴으로 짤 것. (목표값이 한 점으로 수렴하던, 여러 점으로 발산하던 무조건 목표값에서 시작(즉, back to front)
   즉, 목표가 M,N 이라면 cal(1,1)이 아닌, cal(M,N)에서 시작해야함.  answer = cal(M,N)
