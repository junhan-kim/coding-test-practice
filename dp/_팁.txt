1. top down

int dp[n];
for(int i = 0; i < n; i++){ dp[i] = -1; }   // 1. 메모 초기화

int fibonacci(int n) // 2. 인자 n이 탐색 트리의 루트 노드 값이 됨
{
    if (n == 0) return 0;   // 3. 리프노드의 역할을 수행하는 베이스 케이스에서는 고유값을 리턴하여 호출 스택 pop
    if (n == 1) return 1;   // 
 
    if (dp[n] != -1) return dp[n];  // 4. 현재 인덱스(n)에 대한 메모가 존재하면 메모를 반환 
 
    dp[n] = fibonacci(n - 1) + fibonacci(n - 2);  // 5. 점화식을 통한 현재 노드에서의 결과 도출 및 메모이제이션
    return dp[n];  // 6. 결과를 반환하며 호출 스택 pop
}

fibonacci(5); // 7. 호출 스택 push

<풀이법>
1. 탐색의 구조를 재귀 형태로 만들 수 있는 문제인지 판단
2. 베이스 케이스, 계산 결과 리턴 -> 재귀 형태 만들기      // 재귀만으로도 풀리긴함. 단 탐색시간이 기하급수적으로 늘어나서 시간초과
3. 메모 초기화, 메모 get, 메모 put -> 메모이제이션 추가  // 메모리를 조금 더 써서 시간을 획기적으로 줄임 

<유형>
1. 피보나치류 문제 : 현재 결과 연산을 위해 이전 결과를 사용
2. 최적해 : 탐색을 통해 최대값 or 최소값 구하기 
 -> 각 노드가 2~3가지 경우로 나뉨  ex) 사거나 or 안 사거나, 계단을 0칸 or 1칸 or 2칸 